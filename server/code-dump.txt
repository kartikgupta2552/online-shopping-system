package com.apnacart.entity;

import java.time.LocalDateTime;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import jakarta.persistence.*;
import lombok.*;

@Entity 
@Table(name = "users")
@Data //create getter and setter using lombok
public class User {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY) //tells db to generate unique ids
	private Long userId;
	
	@Column(nullable = false, length = 50) //name is mandatory for user registration
	private String userName;
	
	@Column(nullable = false, length = 15,unique = true)//length 15 for extra buffer in formatting, unique no for each user hence unique true
	private String mobileNo;
	
	@Column(nullable = false, length = 100, unique = true) //no duplicate email allowed,also email is mandatory
	private String email;
	
	@Column(length = 500)//address is not mandatory, can be added later in update user
	private String address;
	
	@Column(nullable = false, length = 255)//length 255 coz password saved as hashed value
	private String password;
	
	@Enumerated(EnumType.STRING)
	@Column(nullable = false)//every user must have a role
	private UserRole role = UserRole.CUSTOMER;//make new users as customers by default
	
	@Enumerated(EnumType.STRING)
	@Column(nullable = false)
	private UserStatus status = UserStatus.ACTIVE;
	
	@CreationTimestamp //hibernate auto sets time when record is first created
	@Column(updatable = false) //can't modify it any further once created
	private LocalDateTime createdAt;
	
	
	@UpdateTimestamp
	private LocalDateTime updatedAt;
	
}//User class ends
package com.apnacart.entity;

public enum UserRole {
	CUSTOMER, //Regular users who buy products
	ADMIN, //The gods who can see and control everything
	DELIVERY_PARTNER //The heroes who deliver products to lazy people like us
}
package com.apnacart.entity;

public enum UserStatus {
	/* 
		Can login and use all features
		Can place orders
		Can browse products
		Everything works normally
	 */
	ACTIVE,
	
	/*
	  	User clicked “Deactivate Account”
		Can be reactivated by user request
		Temporary suspension
	 */
	INACTIVE,
	
	/*
	  	Admin blocked them for policy violations
		Fake orders, abusive behavior, fraud attempts
		Cannot login until admin unblocks them
	 */
	BLOCKED
}
package com.apnacart.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class UserLoginDto {
	
	@NotBlank(message = "email is mandatory")
	@Email(message = "please provide a valid email address")
	private String email;
	
	
	@NotBlank(message = "password is mandatory")
	private String password;

}//UserLoginDto ends
package com.apnacart.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class UserRegistrationDto {
	
	@NotBlank(message = "name is mandatory")
	@Size(min = 2, max = 50, message = "name must be between 2-50 characters")
	private String userName;
	
	@NotBlank(message = "email is mandatory")
	@Email(message = "please provide a valid email address")
	@Size(max = 100, message = "email too long! provide email under 100 characters")
	private String email;
	
	@NotBlank(message = "mobile number is mandatory")
	@Pattern(regexp = "^[6-9]\\d{9}$", message = "Please provide a valid Indian mobile number")
	//validation - first digit must be between 6 and 9,followed by exactly 9 digits
	private String mobileNo;
	
	@NotBlank(message = "password is mandatory!!!")
	@Size(min = 8, max = 20,message = "password must be 8-20 characters long")
	@Pattern(
	        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&].*$",
	        message = "Password must contain at least one uppercase, one lowercase, one number, and one special character")
	private String password;
	
	@Size(max = 500, message = "address must be under 500 characters")
	private String address;

}//UserRegistrationDto class ends
package com.apnacart.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class UserUpdateDto {

	@Size(min = 2, max = 50, message = "Name must be between 2-50 characters")
	private String userName;
	
	@Email(message = "provide a valid email address")
	@Size(max = 100, message = "Email too long")
	private String email;
	
	@Pattern(regexp = "^[6-9]\\d{9}$", message = "Please provide a valid Indian mobile number")
	private String mobileNo;
	
	@Size(max = 500, message = "Address is too long")
	private String address;
	
	//skipped = password,status, role
	
}//UserUpdateDto ends
package com.apnacart.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
	private boolean success;
	private String message;
	private T data;

	//static factory methods for common responses
	public static <T> ApiResponse<T> success (String message, T data){
		return new ApiResponse<>(true, message, data);
	}
	
	public static <T> ApiResponse<T> error(String message){
		return new ApiResponse<>(false,message, null);
	}
	
}//ApiResponse ends
package com.apnacart.dto.response;

import java.time.LocalDateTime;

import com.apnacart.entity.UserRole;
import com.apnacart.entity.UserStatus;

import lombok.Data;

@Data
public class UserResponseDto {
	private Long userId;
	private String userName;
	private String mobileNo;
	private String email;
	private String address;
	private UserRole role;
	private UserStatus status;
	private LocalDateTime registeredOn;
	
	//skipped password and updatedAt

}//UserResponseDto ends
package com.apnacart.util;

import org.springframework.stereotype.Component;

import com.apnacart.dto.request.UserRegistrationDto;
import com.apnacart.dto.request.UserUpdateDto;
import com.apnacart.dto.response.UserResponseDto;
import com.apnacart.entity.User;


@Component
public class UserMapper {
	
	//convert UserRegistrationDto to User entity
	public User toEntity(UserRegistrationDto dto) {
		User user = new User();
		user.setUserName(dto.getUserName());
		user.setEmail(dto.getEmail());
		user.setMobileNo(dto.getMobileNo());
		user.setPassword(dto.getPassword()); //to be hashed in the service layer
		user.setAddress(dto.getAddress());
		//role and status are set by default in the user entity when it is created.
		return user;
	}//toEntity() ends
	
	//convert User entity to UserResponseDto
	public UserResponseDto toResponseDto(User user) {
		UserResponseDto dto = new UserResponseDto();
		dto.setUserId(user.getUserId());
		dto.setUserName(user.getUserName());
		dto.setEmail(user.getEmail());
		dto.setMobileNo(user.getMobileNo());
		dto.setAddress(user.getAddress());
		dto.setRole(user.getRole());
		dto.setStatus(user.getStatus());
		dto.setRegisteredOn(user.getCreatedAt());
		return dto;
	}//toResponseDto() ends
	
	//update existing user entity with UserUpdateDto
	public void updateEntity(User existingUser,UserUpdateDto dto) {
		//update only non-null fields => partial updates
		if(dto.getUserName()!=null) {
			existingUser.setUserName(dto.getUserName());
		}
		
		if(dto.getEmail()!=null) {
			existingUser.setEmail(dto.getEmail());
		}
		
		if(dto.getMobileNo()!=null) {
			existingUser.setMobileNo(dto.getMobileNo());
		}
		
		if(dto.getAddress()!=null) {
			existingUser.setAddress(dto.getAddress());
		}
	}//updateEntity() ends
	
	
}//UserMapper() ends
package com.apnacart.service;

import java.util.List;

import com.apnacart.dto.request.UserLoginDto;
import com.apnacart.dto.request.UserRegistrationDto;
import com.apnacart.dto.request.UserUpdateDto;
import com.apnacart.dto.response.UserResponseDto;
import com.apnacart.entity.User;
import com.apnacart.entity.UserStatus;

public interface UserService {

	//create new user(registration)
	User createUser(User user);
	
	//get user by id
	User getUserById(Long userId);
	
	//get user by email
	User getUserByEmail(String email);
	
	//get user by mobileNo
	User getUserByMobileNo(String mobileNo);
	
	//get all users(admin fn)
	List<User> getAllUsers();
	
	//update user
	User updateUser(Long userId, User updatedUser);
	
	//delete user
	void deleteUser(Long userId);
	
	//change user status(admin fn)
	User changeUserStatus(Long userId, UserStatus status);
	
	//get users by status
	List<User> getUsersByStatus(UserStatus status);
	
	//check if email available for registration
	boolean isEmailAvailable(String email);
	
	//check if mobileNo available for registration
	boolean isMobileNoAvailable(String mobileNo);
	
	//dto-based methods
	UserResponseDto registerUser(UserRegistrationDto registrationDto);
	UserResponseDto updateUser(Long userId, UserUpdateDto updateDto);
	UserResponseDto getUserResponseById(Long userId);
	List<UserResponseDto> getAllUserResponses();
	UserResponseDto authenticateUser(UserLoginDto loginDto);
	
}//UserService interface ends
package com.apnacart.service.impl;


import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.apnacart.dao.UserDao;
import com.apnacart.dto.request.UserLoginDto;
import com.apnacart.dto.request.UserRegistrationDto;
import com.apnacart.dto.request.UserUpdateDto;
import com.apnacart.dto.response.UserResponseDto;
import com.apnacart.entity.User;
import com.apnacart.entity.UserStatus;
import com.apnacart.exception.AccountInactiveException;
import com.apnacart.exception.InvalidCredentialsException;
import com.apnacart.exception.UserAlreadyExistsException;
import com.apnacart.exception.UserNotFoundException;
import com.apnacart.service.UserService;
import com.apnacart.util.UserMapper;

//import jakarta.transaction.Transactional;

@Service
@Transactional //if something goes wrong, all db changes get rolled back!
public class UserServiceImpl implements UserService {
	
	@Autowired
	private UserDao userRepo;
	
	@Autowired
	private UserMapper userMapper;
	
	@Autowired
	private PasswordEncoder passwordEncoder;

	@Override
	public User createUser(User user) {
		// check if the email is available
		if(!isEmailAvailable(user.getEmail())) {
			throw new UserAlreadyExistsException("Email already exists : " + user.getEmail());
		}
		
		//check if mobileNo available
		if(!isMobileNoAvailable(user.getMobileNo())) {
			throw new UserAlreadyExistsException("Mobile number already exists : " + user.getMobileNo());
		}
		
		// TODO: Add password hashing here later(done)
		String hashedPassword = passwordEncoder.encode(user.getPassword());
		user.setPassword(hashedPassword);
		
		return userRepo.save(user);
	}//createUser() ends

	@Override
	@Transactional(readOnly = true) //only fetches data, no modification, so this tag makes it fast
	public User getUserById(Long userId) {
		return userRepo.findByUserId(userId)
				.orElseThrow(() -> new UserNotFoundException("user not found with id : " + userId));
	}//getUserById() ends

	@Override
	@Transactional(readOnly = true)
	public User getUserByEmail(String email) {
		return userRepo.findByEmail(email)
				.orElseThrow(() -> new UserNotFoundException("user not found with email : " + email));
	}//getUserByEmail() ends

	@Override
	@Transactional(readOnly = true)
	public User getUserByMobileNo(String mobileNo) {
		return userRepo.findByMobileNo(mobileNo)
				.orElseThrow(() -> new UserNotFoundException("user not found with mobile no : " + mobileNo));
	}//getUserByMobileNo() ends

	@Override
	@Transactional(readOnly = true)
	public List<User> getAllUsers() {
		return userRepo.findAll();
	}//getAllUsers() ends

	@Override
	public User updateUser(Long userId, User updatedUser) {
		//find existing user
		User existingUser = getUserById(userId);
		
		//check if email is being changed and if new email is available or not
		if(!existingUser.getEmail().equals(updatedUser.getEmail())){ 
			if(!isEmailAvailable(updatedUser.getEmail())) {
				throw new UserAlreadyExistsException("this email already exists!" + updatedUser.getEmail());
			}
		}
		
		//check if mobileNo is changed and if new no is available or not
		if(!existingUser.getMobileNo().equals(updatedUser.getMobileNo())) {
			if(!isMobileNoAvailable(updatedUser.getMobileNo())) {
				throw new UserAlreadyExistsException("this mobile number already exists : " + updatedUser.getMobileNo());
			}
		}
		
		//if none of the above true, update the new mobile no and/or email
		existingUser.setUserName(updatedUser.getUserName());
		existingUser.setEmail(updatedUser.getEmail());
		existingUser.setMobileNo(updatedUser.getMobileNo());
		existingUser.setAddress(updatedUser.getAddress());
		
		return userRepo.save(existingUser);
	}//updateUser() ends

	@Override
	public void deleteUser(Long userId) {
		//check if user already exists or not
		if(!userRepo.existsById(userId)) {
			throw new UserNotFoundException("No such user with id : " + userId);
		}
		userRepo.deleteById(userId);

	}//deleteUser() ends

	@Override
	public User changeUserStatus(Long userId, UserStatus status) {
		//find the existing user
		User existingUser = getUserById(userId);
		existingUser.setStatus(status);
		return userRepo.save(existingUser);
	}//changeUserStatus() ends

	@Override
	@Transactional(readOnly = true)
	public List<User> getUsersByStatus(UserStatus status) {
		return userRepo.findByStatus(status);
	}//getUsersByStatus() ends

	@Override
	@Transactional(readOnly = true)
	public boolean isEmailAvailable(String email) {
		return !userRepo.existsByEmail(email); //returns true if no such email present in the db
	}//isEmailAvailable() ends

	@Override
	@Transactional(readOnly = true)
	public boolean isMobileNoAvailable(String mobileNo) {
		return !userRepo.existsByMobileNo(mobileNo); //returns true if no such mobile no present in the db
	}//isMobileNoAvailable() ends

	//=====================================================================================================================
	
	//new dto-based registration method
	@Override
	public UserResponseDto registerUser(UserRegistrationDto registrationDto) {
		//validate email availability
		if(!isEmailAvailable(registrationDto.getEmail())) {
			throw new UserAlreadyExistsException("this email already exists : " + registrationDto.getEmail());
		}
		
		//validate mobileNo availability
		if(!isMobileNoAvailable(registrationDto.getMobileNo())) {
			throw new UserAlreadyExistsException("this mobile no already exists : " + registrationDto.getMobileNo());
		}
		
		//convert dto to user entity
		User user = userMapper.toEntity(registrationDto);
		
		//TODO: hash password here (done)
		String hashedPassword = passwordEncoder.encode(registrationDto.getPassword());
		user.setPassword(hashedPassword);
		
		//save user
		User savedUser = userRepo.save(user);
		
		//convert user entity to response dto
		return userMapper.toResponseDto(savedUser);
		
	}//registerUser() ends

	
	// //new dto based update method
	@Override
	public UserResponseDto updateUser(Long userId, UserUpdateDto updateDto) {
		
		//find the existing user
		User existingUser = getUserById(userId);
		
		//validate email exists if it is being changed
		if(updateDto.getEmail()!=null && !existingUser.getEmail().equals(updateDto.getEmail())) {
			if(!isEmailAvailable(updateDto.getEmail())) {
				throw new UserAlreadyExistsException("this email already exists : " + updateDto.getEmail());
			}
		}
		
		//validate mobile no exists
		if(updateDto.getMobileNo()!=null && !existingUser.getMobileNo().equals(updateDto.getMobileNo())) {
			if(!isMobileNoAvailable(updateDto.getMobileNo())) {
				throw new UserAlreadyExistsException("this mobile number already exists : " + updateDto.getMobileNo());
			}
		}
		
		//update the existing entity with dto data
		userMapper.updateEntity(existingUser, updateDto);
		
		//save and return the dto
		User updatedUser = userRepo.save(existingUser);
		return userMapper.toResponseDto(updatedUser);
	}//updateUser() ends

	//dto-based getter methods
	@Override
	@Transactional(readOnly = true)
	public UserResponseDto getUserResponseById(Long userId) {
		User user = getUserById(userId);
		return userMapper.toResponseDto(user);
	}//getUserResponseById() ends

	@Override
	@Transactional(readOnly = true)
	public List<UserResponseDto> getAllUserResponses() {
		return userRepo.findAll()
				.stream()
				.map(userMapper::toResponseDto)
				.toList();
	}//getAllUserResponses() ends

	@Override
	public UserResponseDto authenticateUser(UserLoginDto loginDto) {
		//find user by email
		User user = userRepo.findByEmail(loginDto.getEmail())
				.orElseThrow(()-> new InvalidCredentialsException("invalid email or password!"));
		
		//verify password using bcrypt
		boolean passwordMatches = passwordEncoder.matches(loginDto.getPassword(), user.getPassword());
		
		if(!passwordMatches) {
			throw new InvalidCredentialsException("invalid email or password");
		}
		
		//check if the user is active(blocked user cannot login!)
		if(user.getStatus() != UserStatus.ACTIVE) {
			throw new AccountInactiveException("This Account is " + user.getStatus().toString().toLowerCase() + 
					". Please contact support.");
		}
		
		//return user info(without password, obviously)
		return userMapper.toResponseDto(user);
	}//authenticateUser() ends

}//UserServiceImpl ends
package com.apnacart.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.apnacart.dto.request.UserLoginDto;
import com.apnacart.dto.request.UserRegistrationDto;
import com.apnacart.dto.request.UserUpdateDto;
import com.apnacart.dto.response.ApiResponse;
import com.apnacart.dto.response.UserResponseDto;
import com.apnacart.entity.User;
import com.apnacart.entity.UserStatus;
import com.apnacart.service.UserService;

import jakarta.validation.Valid;

import org.springframework.web.bind.annotation.RequestParam;


@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "http://localhost:3000")//for react frontend
public class UserController {
	
	@Autowired
	private UserService userService;
	
	// CREATE - register new user
	@PostMapping
	public ResponseEntity<User> createUser(@RequestBody User user){
			User createdUser = userService.createUser(user);
			return new ResponseEntity<>(createdUser,HttpStatus.CREATED);
	}//createUser() ends
	
	// READ - get user by Id
	@GetMapping("/{userId}")
	public ResponseEntity<User> getUserById(@PathVariable Long userId){
			User user = userService.getUserById(userId);
			return new ResponseEntity<>(user, HttpStatus.OK);
	}//getUserById() ends
	
	// READ - get all users (admin functionality)
	@GetMapping
	public ResponseEntity<List<User>> getAllUsers(){
		List<User> users = userService.getAllUsers();
		return new ResponseEntity<>(users, HttpStatus.OK);
	}//getAllUsers() ends
	
	// READ - get user by email (login support)
	@GetMapping("/email/{email}")
	public ResponseEntity<User> getUserByEmail(@PathVariable String email){
			User user = userService.getUserByEmail(email);
			return new ResponseEntity<>(user, HttpStatus.OK);
	}//getUserByEmail() ends
	
	// READ - get user by mobile number
	@GetMapping("/mobile/{mobileNo}")
	public ResponseEntity<User> getUserByMobileNo(@PathVariable String mobileNo) {
			User user = userService.getUserByMobileNo(mobileNo);
			return new ResponseEntity<>(user, HttpStatus.OK);
	}//getUserByMobileNo() ends
	
	
	// UPDATE - update a user
	@PutMapping("/{userId}")
	public ResponseEntity<User> updateUser(@PathVariable Long userId, @RequestBody User user) {
			User updatedUser = userService.updateUser(userId, user);
			return new ResponseEntity<>(updatedUser, HttpStatus.OK);	
	}//updateUser() ends
	
	
	// DELETE - delete a user
	@DeleteMapping("/{userId}")
	public ResponseEntity<String> deleteUser(@PathVariable Long userId){
			userService.deleteUser(userId);
			return new ResponseEntity<>("user deleted succesfully",HttpStatus.OK);
	}//deleteUser() ends
	
	
	// PATCH - change user status (admin functionality)
	@PatchMapping("/{userId}/status")
	public ResponseEntity<User> changeUserStatus(@PathVariable Long userId, @RequestParam UserStatus status){
			User updatedUser = userService.changeUserStatus(userId, status);
			return new ResponseEntity<>(updatedUser,HttpStatus.OK);
	}//changeUserStatus()ends
	
	// READ - get user by status (admin functionality)
	@GetMapping("/status/{status}")
	public ResponseEntity<List<User>> getUserByStatus(@PathVariable UserStatus status){
		List<User> users = userService.getUsersByStatus(status);
		return new ResponseEntity<>(users, HttpStatus.OK);
	}//getUserByStatus() ends
	
	// utility endpoints for validation - check email and mobile
	@GetMapping("/check-email/{email}")
	public ResponseEntity<String> checkEmailAvailability(@PathVariable String email){
		boolean available = userService.isEmailAvailable(email);
		String message = "Email " + email + " is " + (available? "available" : "taken");
		return new ResponseEntity<>(message, HttpStatus.OK);
	}//checkEmailAvailability() ends
	
	@GetMapping("/check-mobile/{mobileNo}")
	public ResponseEntity<String> checkMobileNoAvailability(@PathVariable String mobileNo){
		boolean available = userService.isMobileNoAvailable(mobileNo);
		String message = "Mobile no " + mobileNo + " is " + (available? "available" : "taken");
		return new ResponseEntity<>(message, HttpStatus.OK);
	}//checkMobileNoAvailability() ends
	
	//=============================================================================================
	
	// new dto-based registration endpoint
	@PostMapping("/register")
	public ResponseEntity<ApiResponse<UserResponseDto>> registerUser(@Valid @RequestBody UserRegistrationDto registrationDto){
		//@valid enables validation on the objects/fields(nested as well)
			UserResponseDto user = userService.registerUser(registrationDto);
			ApiResponse<UserResponseDto> response = ApiResponse.success("user registered succesfully", user);
			return ResponseEntity.status(HttpStatus.CREATED).body(response);

	}//registerUser() ends
	
	// new dto-based update profile endpoint
	@PutMapping("{userId}/profile")
	public ResponseEntity<ApiResponse<UserResponseDto>> updateUserProfile(@PathVariable Long userId,
			@Valid @RequestBody UserUpdateDto updateDto) {
			UserResponseDto user = userService.updateUser(userId, updateDto);
			ApiResponse<UserResponseDto> response = ApiResponse.success("user updated succesfully", user);
			return ResponseEntity.ok(response);
	}// updateUserProfile() ends
	
	//new dto-based get all users
	@GetMapping("/all")
	public ResponseEntity<ApiResponse<List<UserResponseDto>>> getAllUsersClean(){
		List<UserResponseDto> users = userService.getAllUserResponses();
		ApiResponse<List<UserResponseDto>> response = ApiResponse.success("users retrueved succesfully", users);
		return ResponseEntity.ok(response);
	}//getAllUsersClean() ends
	

	//login authentication
	@PostMapping("/login")
	public ResponseEntity<ApiResponse<UserResponseDto>> loginUser(@Valid @RequestBody UserLoginDto loginDto){
			UserResponseDto user = userService.authenticateUser(loginDto);
			ApiResponse<UserResponseDto> response = ApiResponse.success("Login Succesful!", user);
			return ResponseEntity.ok(response);
	}//loginUser() ends
	
}//UserController class ends
package com.apnacart.dao;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.apnacart.entity.User;
import com.apnacart.entity.UserStatus;

import java.util.List;

//data access layer
@Repository
public interface UserDao extends JpaRepository<User, Long> {

	//find user by email(login functionality)
	Optional<User> findByEmail(String email);
	//optional used for safe null handling (for the user not found case)
	
	//find user by phone no
	Optional<User> findByMobileNo(String mobileNo);
	
	//find user by id
	Optional<User> findByUserId(Long userId);
	
	//check if mail already exists(prevents duplicate user registration)
	boolean existsByEmail(String email); 
	
	//check if phone already exists(prevents duplicate user registration)
	boolean existsByMobileNo(String mobileNo);
	
	//find user by status(admin functionality)
	List<User> findByStatus(UserStatus status);
	
	
}//UserRepository interface ends
package com.apnacart.entity;

import java.time.LocalDateTime;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import jakarta.persistence.*;
import lombok.*;

@Entity 
@Table(name = "users")
@Data //create getter and setter using lombok
public class User {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY) //tells db to generate unique ids
	private Long userId;
	
	@Column(nullable = false, length = 50) //name is mandatory for user registration
	private String userName;
	
	@Column(nullable = false, length = 15,unique = true)//length 15 for extra buffer in formatting, unique no for each user hence unique true
	private String mobileNo;
	
	@Column(nullable = false, length = 100, unique = true) //no duplicate email allowed,also email is mandatory
	private String email;
	
	@Column(length = 500)//address is not mandatory, can be added later in update user
	private String address;
	
	@Column(nullable = false, length = 255)//length 255 coz password saved as hashed value
	private String password;
	
	@Enumerated(EnumType.STRING)
	@Column(nullable = false)//every user must have a role
	private UserRole role = UserRole.CUSTOMER;//make new users as customers by default
	
	@Enumerated(EnumType.STRING)
	@Column(nullable = false)
	private UserStatus status = UserStatus.ACTIVE;
	
	@CreationTimestamp //hibernate auto sets time when record is first created
	@Column(updatable = false) //can't modify it any further once created
	private LocalDateTime createdAt;
	
	
	@UpdateTimestamp
	private LocalDateTime updatedAt;
	
}//User class ends
package com.apnacart.entity;

public enum UserRole {
	CUSTOMER, //Regular users who buy products
	ADMIN, //The gods who can see and control everything
	DELIVERY_PARTNER //The heroes who deliver products to lazy people like us
}
package com.apnacart.entity;

public enum UserStatus {
	/* 
		Can login and use all features
		Can place orders
		Can browse products
		Everything works normally
	 */
	ACTIVE,
	
	/*
	  	User clicked “Deactivate Account”
		Can be reactivated by user request
		Temporary suspension
	 */
	INACTIVE,
	
	/*
	  	Admin blocked them for policy violations
		Fake orders, abusive behavior, fraud attempts
		Cannot login until admin unblocks them
	 */
	BLOCKED
}
